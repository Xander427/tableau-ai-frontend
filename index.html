<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Data Assistant</title>

  <!-- Local extension API - you already have this file in your site root -->
  <script src="tableau.extensions.1.14.0.min.js"></script>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f5f6fa;
      margin: 0;
      padding: 15px;
    }

    h2 { margin-top: 0; }
    #question {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    #askButton {
      display: block;
      margin-top: 10px;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: #2f7df6;
      color: white;
      font-weight: 500;
      cursor: pointer;
    }
    #askButton:hover { background: #1e5fd1; }

    #output {
      margin-top: 15px;
      padding: 10px;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 50vh;
      overflow: auto;
    }

    .log { color: #333; font-size: 12px; margin-top: 6px; }
    .warn { color: #b36b00; }
    .err { color: #b00020; }
  </style>

  <script>
    // ---------- Initialization ----------
    let globalColumns = null;

    // In your init() function:
    async function init() {
      try {
        await tableau.extensions.initializeAsync();
        console.log("✅ Tableau Extension initialized");

        const dashboard = tableau.extensions.dashboardContent.dashboard;
        const targetWs = findWorksheetByName(dashboard, "Report Builder ");
        
        // Fetch and cache columns during init
        if (targetWs) {
          const summaryData = await targetWs.getSummaryDataAsync({ maxrows: 10000 });
          globalColumns = summaryData.columns;
          console.log("Columns cached during init:", globalColumns.map(c => c.fieldName));
        }
        
      } catch (err) {
        console.error("Failed to initialize:", err);
      }
    }

    document.addEventListener("DOMContentLoaded", init);

    // ---------- Helpers ----------
    // Normalize names (trim) to avoid trailing-space mismatches
    function normalizeName(n) { return (n || "").toString().trim(); }

    // Try to find the right worksheet: prefer exact trimmed match, else fallback to first
    function findWorksheetByName(dashboard, desiredName) {
      if (!dashboard || !dashboard.worksheets || dashboard.worksheets.length === 0) return null;
      const trimmed = normalizeName(desiredName);
      const found = dashboard.worksheets.find(ws => normalizeName(ws.name) === trimmed);
      if (found) return found;
      // fallback: try includes
      const fuzzy = dashboard.worksheets.find(ws => normalizeName(ws.name).includes(trimmed));
      return fuzzy || dashboard.worksheets[0];
    }

    // Extract a usable formatted value from a summary cell
    function getCellFormattedValue(cell) {
      if (!cell) return null;
      return cell.formattedValue ?? cell._formattedValue ?? cell.value ?? cell._value ?? null;
    }

    // ---------- Core: apply filters from AI response ----------
    async function applyFiltersFromResponse(filtersObj, desiredWorksheetName = "Report Builder ") {
      if (!window.tableau) {
        console.warn("Tableau object not detected; skipping filter apply.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      const dashboard = tableau.extensions.dashboardContent.dashboard;
      const targetWs = findWorksheetByName(dashboard, desiredWorksheetName);
      if (!targetWs) {
        console.warn("No worksheet found to apply filters to.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      console.log("========== APPLYING FILTERS ==========");
      console.log("Filters from AI:", JSON.stringify(filtersObj, null, 2));
      
      const applied = [];
      const skipped = [];

      // Get current filter state
      let worksheetFilters = [];
      try {
        worksheetFilters = await targetWs.getFiltersAsync();
        console.log("Current worksheet filters:", worksheetFilters.map(f => ({
          field: f.fieldName,
          type: f.filterType,
          values: f.appliedValues?.map(v => v.value)
        })));
      } catch (e) {
        console.warn("Could not retrieve worksheet filters metadata:", e);
      }

      // Get parameters
      let parameters = [];
      try {
        parameters = await dashboard.getParametersAsync();
        console.log("Available parameters:", parameters.map(p => p.name));
      } catch (e) {
        console.warn("Could not retrieve parameters:", e);
      }

      // Use cached columns instead of fetching fresh
      const columns = globalColumns;
      if (!columns) {
        console.error("❌ No cached columns available! Make sure init() completed successfully.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }
      console.log("Using cached columns:", columns.map(c => `'${c.fieldName}'`));

      // We'll fetch summary data only if needed for date range auto-detection
      let summaryData = null;

      for (const [fieldRaw, rawVals] of Object.entries(filtersObj || {})) {
        const fieldName = fieldRaw.trim();
        console.log(`\n--- Processing field: "${fieldName}" ---`);
        console.log(`Values:`, rawVals);
        
        // Map Date Granularity to parameter
        let actualFieldName = fieldName;
        if (fieldName.toLowerCase() === "date granularity") {
          actualFieldName = "Date Granularity Selector";
        }

        // CHECK PARAMETERS
        const param = parameters.find(p => normalizeName(p.name) === normalizeName(actualFieldName));
        if (param) {
          console.log(`Found parameter: ${actualFieldName}`);
          if (Array.isArray(rawVals) && rawVals.length > 0) {
            try {
              await param.changeValueAsync(String(rawVals[0]).trim());
              applied.push(actualFieldName);
              console.log(`✅ Parameter set successfully`);
            } catch (err) {
              console.error(`❌ Failed to set parameter:`, err);
              skipped.push(fieldName);
            }
          }
          continue;
        }

        // CHECK FILTER METADATA
        const wf = worksheetFilters.find(f => normalizeName(f.fieldName) === normalizeName(actualFieldName));
        
        if (wf) {
          console.log(`Found filter metadata:`, { name: wf.fieldName, type: wf.filterType });
          
          // Use the actual field name from metadata
          actualFieldName = wf.fieldName;
          
          // For range filters (date)
          if (wf.filterType === "range") {
            console.log(`Processing RANGE filter for ${actualFieldName}`);
            
            if (Array.isArray(rawVals) && rawVals.length >= 1 && rawVals.length <= 2) {
              try {
                let minVal = rawVals[0];
                let maxVal = rawVals.length === 2 ? rawVals[1] : null;
                
                // Auto-detect max date if only one provided
                if (rawVals.length === 1) {
                  console.log(`Only one date provided, auto-detecting max date from data...`);
                  
                  // Fetch summary data only now, when needed
                  if (!summaryData) {
                    try {
                      summaryData = await targetWs.getSummaryDataAsync({ maxRows: 10000 });
                      console.log("Fetched summary data for date range detection");
                    } catch (e) {
                      console.warn("Could not retrieve summary data:", e);
                    }
                  }
                  
                  // Find the date column index
                  const dateColIndex = columns?.findIndex(c => 
                    normalizeName(c.fieldName).toLowerCase() === 'date'
                  );
                  
                  if (dateColIndex !== -1 && summaryData) {
                    const dateValues = summaryData.data
                      .map(row => getCellFormattedValue(row[dateColIndex]))
                      .filter(v => v !== null && v !== undefined)
                      .sort();
                    
                    if (dateValues.length > 0) {
                      maxVal = dateValues[dateValues.length - 1];
                      console.log(`Auto-detected max date: ${maxVal}`);
                    } else {
                      console.warn("No date values found in data");
                      skipped.push(fieldName);
                      continue;
                    }
                  } else {
                    console.warn("Could not find date column in data");
                    skipped.push(fieldName);
                    continue;
                  }
                }
                
                // Convert to Date objects
                const minDate = new Date(minVal);
                const maxDate = new Date(maxVal);
                
                console.log(`Applying range: ${minDate.toISOString()} to ${maxDate.toISOString()}`);
                
                await targetWs.applyRangeFilterAsync(actualFieldName, { 
                  min: minDate, 
                  max: maxDate 
                });
                applied.push(actualFieldName);
                console.log(`✅ Range filter applied successfully`);
                
              } catch (err) {
                console.error(`❌ Failed to apply range filter:`, err);
                skipped.push(fieldName);
              }
            } else {
              console.warn(`❌ Range filter expected 1-2 values, got:`, rawVals);
              skipped.push(fieldName);
            }
            continue;
          }
        }

        // For categorical filters (Channel, etc.)
        // STRICT COLUMN MATCHING - NO FUZZY MATCHING
        let colIndex = columns?.findIndex(c => 
          normalizeName(c.fieldName).toLowerCase() === normalizeName(actualFieldName).toLowerCase()
        );
        
        if (colIndex === -1) {
          console.error(`❌ Field '${actualFieldName}' not found. Available:`, 
            columns?.map(c => `'${c.fieldName}'`));
          skipped.push(fieldName);
          continue;
        }

        const actualTableauFieldName = columns[colIndex].fieldName;
        console.log(`✅ Using column: '${actualTableauFieldName}'`);

        // TRUSTED FIELDS - bypass domain validation
        const TRUSTED_FIELDS = ["Channel", "Publisher", "Platform"];
        
        if (TRUSTED_FIELDS.some(field => normalizeName(field) === normalizeName(actualFieldName))) {
          console.log(`Bypassing validation for: ${actualFieldName}`);
          const validatedValues = rawVals.map(v => String(v).trim());
          
          try {
            await targetWs.applyFilterAsync(actualTableauFieldName, validatedValues, tableau.FilterUpdateType.Replace);
            applied.push(actualFieldName);
            console.log(`✅ Trusted filter applied`);
            continue;
          } catch (err) {
            console.error(`❌ Failed:`, err);
            skipped.push(fieldName);
            continue;
          }
        }

        // For other fields, get full domain using getDomainAsync
        if (!Array.isArray(rawVals) || rawVals.length === 0) {
          console.warn(`❌ No values for filter ${actualTableauFieldName}`);
          skipped.push(fieldName);
          continue;
        }

        let domainValues = new Map();
        let domainDisplay = [];

        if (wf && wf.getDomainAsync) {
          try {
            const domain = await wf.getDomainAsync();
            console.log(`Getting full domain for ${actualTableauFieldName}...`);
            
            for (const domainVal of domain.values) {
              const fv = getCellFormattedValue(domainVal);
              if (fv !== null && fv !== undefined) {
                const key = String(fv).toLowerCase();
                if (!domainValues.has(key)) {
                  domainValues.set(key, fv);
                  domainDisplay.push(fv);
                }
              }
            }
            console.log(`Full domain values (${domainDisplay.length}):`, domainDisplay);
          } catch (e) {
            console.warn(`Could not get domain, falling back to summary data:`, e);
          }
        }

        // If getDomainAsync failed or returned empty, use summary data as fallback
        if (domainValues.size === 0) {
          console.warn(`Using summary data for domain (may be filtered)`);
          
          // Fetch summary data if not already fetched
          if (!summaryData) {
            try {
              summaryData = await targetWs.getSummaryDataAsync({ maxRows: 10000 });
            } catch (e) {
              console.warn("Could not retrieve summary data:", e);
            }
          }
          
          if (summaryData) {
            for (const row of summaryData.data) {
              const cell = row[colIndex];
              const fv = getCellFormattedValue(cell);
              if (fv !== null && fv !== undefined) {
                const key = String(fv).toLowerCase();
                if (!domainValues.has(key)) {
                  domainValues.set(key, fv);
                  domainDisplay.push(fv);
                }
              }
            }
          }
        }

        console.log(`Domain values for ${actualTableauFieldName}:`, domainDisplay);

        // Validate each AI-provided value
        const validatedValues = [];
        for (const rawVal of rawVals) {
          const lowerRawVal = String(rawVal).toLowerCase();
          if (domainValues.has(lowerRawVal)) {
            validatedValues.push(domainValues.get(lowerRawVal));
          } else {
            console.error(`❌ Value '${rawVal}' not found in domain. Available:`, domainDisplay);
          }
        }

        if (validatedValues.length === 0) {
          console.error(`❌ No valid values found for filter ${actualTableauFieldName}`);
          skipped.push(fieldName);
          continue;
        }

        try {
          console.log(`Applying categorical filter ${actualTableauFieldName} with:`, validatedValues);
          await targetWs.applyFilterAsync(actualTableauFieldName, validatedValues, tableau.FilterUpdateType.Replace);
          applied.push(actualFieldName);
          console.log(`✅ Categorical filter applied successfully`);
        } catch (err) {
          console.error(`❌ Failed to apply filter:`, err);
          skipped.push(fieldName);
        }
      } // end for each filter

      console.log("\n========== FINAL RESULT ==========");
      console.log("Applied:", applied);
      console.log("Skipped:", skipped);
      return { applied, skipped };
    }

    // ---------- askAI() - calls backend and then applies filters ----------
    async function askAI() {
      const question = document.getElementById("question").value.trim();
      const output = document.getElementById("output");
      if (!question) { output.innerText = "Please enter a question."; return; }
      output.innerHTML = "<em>Thinking...</em>";

      // get user context - capture all 4 fields, but only send username to table.
      const user = tableau.extensions.environment.user;
      const userContext = {
        username: user?.username ?? "unknown",
        fullName: user?.fullName ?? null,
        role: user?.role ?? null,
        domain: user?.domain ?? null
      };

      try {
        const res = await fetch("https://ej-tableau-ai-api-c5gvdag0gdhrbnca.eastus-01.azurewebsites.net/ai_query", {
          method: "POST",
          headers: { "Content-Type": "application/json"
            },
          body: JSON.stringify({ query: question,
            user: userContext
           })
        });

        if (!res.ok) {
          const text = await res.text().catch(()=>null);
          throw new Error(`API request failed: ${res.status} ${res.statusText} ${text||""}`);
        }

        const data = await res.json();

        output.innerHTML = `
          <b>Summary:</b><br>${data.summary || "(no summary)"}<br><br>
          <b>Top rows (sample):</b><br><pre>${JSON.stringify(data.rows?.slice(0,10) ?? [], null, 2)}</pre><br>
          <b>SQL:</b><br><pre>${data.sql ?? "(none)"}</pre>
        `;

        if (data.filters && Object.keys(data.filters).length > 0) {
          console.log("Filters returned by AI:", data.filters);

          const result = await applyFiltersFromResponse(data.filters, "Report Builder ");
          console.log("applyFiltersFromResponse result:", result);

          output.innerHTML += `<div class="log">Filters applied: ${JSON.stringify(result.applied)}</div>`;
          if (result.skipped && result.skipped.length) {
            output.innerHTML += `<div class="warn">Filters skipped / not matched: ${JSON.stringify(result.skipped)}</div>`;
          }
        } else {
          console.log("No filters returned from AI.");
        }

      } catch (err) {
        console.error("askAI() error:", err);
        output.innerHTML = `<div class="err">Error: ${err.message}</div>`;
      }
    }
  </script>
</head>

<body>
  <h2>AI Data Assistant</h2>
  <p>Ask a question about your data:</p>

  <input id="question" placeholder="e.g., Show me Facebook spend by week" />
  <button id="askButton" onclick="askAI()">Ask</button>

  <div id="output"></div>
</body>
</html>