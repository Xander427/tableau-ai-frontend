<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Data Assistant</title>

  <!-- Local extension API - you already have this file in your site root -->
  <script src="tableau.extensions.1.14.0.min.js"></script>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f5f6fa;
      margin: 0;
      padding: 15px;
    }

    h2 { margin-top: 0; }
    #question {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    #askButton {
      display: block;
      margin-top: 10px;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: #2f7df6;
      color: white;
      font-weight: 500;
      cursor: pointer;
    }
    #askButton:hover { background: #1e5fd1; }

    #output {
      margin-top: 15px;
      padding: 10px;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 50vh;
      overflow: auto;
    }

    .log { color: #333; font-size: 12px; margin-top: 6px; }
    .warn { color: #b36b00; }
    .err { color: #b00020; }
  </style>

  <script>
    // ---------- Initialization ----------
    async function init() {
      try {
        await tableau.extensions.initializeAsync();
        console.log("âœ… Tableau Extension initialized. window.tableau:", !!window.tableau);

        const dashboard = tableau.extensions.dashboardContent.dashboard;
        console.log("Dashboard name:", dashboard.name);
        console.log("Worksheets available:", dashboard.worksheets.map(w => w.name));

      } catch (err) {
        console.error("Failed to initialize Tableau Extension:", err);
      }
    }

    document.addEventListener("DOMContentLoaded", init);

    // ---------- Helpers ----------
    // Normalize names (trim) to avoid trailing-space mismatches
    function normalizeName(n) { return (n || "").toString().trim(); }

    // Try to find the right worksheet: prefer exact trimmed match, else fallback to first
    function findWorksheetByName(dashboard, desiredName) {
      if (!dashboard || !dashboard.worksheets || dashboard.worksheets.length === 0) return null;
      const trimmed = normalizeName(desiredName);
      const found = dashboard.worksheets.find(ws => normalizeName(ws.name) === trimmed);
      if (found) return found;
      // fallback: try includes
      const fuzzy = dashboard.worksheets.find(ws => normalizeName(ws.name).includes(trimmed));
      return fuzzy || dashboard.worksheets[0];
    }

    // Extract a usable formatted value from a summary cell
    function getCellFormattedValue(cell) {
      if (!cell) return null;
      return cell.formattedValue ?? cell._formattedValue ?? cell.value ?? cell._value ?? null;
    }

    // ---------- Core: apply filters from AI response ----------
    async function applyFiltersFromResponse(filtersObj, desiredWorksheetName = "Report Builder ") {
      if (!window.tableau) {
        console.warn("Tableau object not detected; skipping filter apply.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      const dashboard = tableau.extensions.dashboardContent.dashboard;
      const targetWs = findWorksheetByName(dashboard, desiredWorksheetName);
      if (!targetWs) {
        console.warn("No worksheet found to apply filters to.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      console.log("Applying filters to worksheet:", targetWs.name);
      const applied = [];
      const skipped = [];

      // Get current filter state
      let worksheetFilters = [];
      try {
        worksheetFilters = await targetWs.getFiltersAsync();
      } catch (e) {
        console.warn("Could not retrieve worksheet filters metadata:", e);
      }

      // Get parameters for the dashboard
      let parameters = [];
      try {
        parameters = await dashboard.getParametersAsync();
        console.log("Available parameters:", parameters.map(p => p.name));
      } catch (e) {
        console.warn("Could not retrieve parameters:", e);
      }

      // Get summary data for validation
      let summaryData = null;
      let columns = null;
      try {
        summaryData = await targetWs.getSummaryDataAsync({ maxRows: 10000 });
        columns = summaryData.columns;
      } catch (e) {
        console.warn("Could not retrieve summary data:", e);
      }

      for (const [fieldRaw, rawVals] of Object.entries(filtersObj || {})) {
        const fieldName = fieldRaw.trim();
        
        // SPECIAL HANDLING FOR DATE GRANULARITY
        // Map the AI's "Date Granularity" to the actual parameter name
        let actualFieldName = fieldName;
        if (fieldName.toLowerCase() === "date granularity") {
          actualFieldName = "Date Granularity Selector"; // The actual parameter name
        }

        // Check if this is a parameter, not a filter
        const param = parameters.find(p => normalizeName(p.name) === normalizeName(actualFieldName));
        if (param) {
          // It's a parameter - set parameter value instead of filter
          if (Array.isArray(rawVals) && rawVals.length > 0) {
            const paramValue = String(rawVals[0]).trim();
            try {
              console.log(`Setting parameter ${actualFieldName} to:`, paramValue);
              await param.changeValueAsync(paramValue);
              applied.push(actualFieldName);
            } catch (err) {
              console.error(`Failed to set parameter ${actualFieldName}:`, err);
              skipped.push(fieldName);
            }
          } else {
            console.warn(`No values for parameter ${actualFieldName}, skipping`);
            skipped.push(fieldName);
          }
          continue; // Move to next field
        }

        // It's a regular filter - proceed with validation
        const colIndex = columns?.findIndex(c => normalizeName(c.fieldName) === normalizeName(actualFieldName));
        if (colIndex === -1) {
          console.warn(`Field '${actualFieldName}' not found in data source`);
          skipped.push(fieldName);
          continue;
        }

        // Get Tableau's actual field name (with correct spacing/case)
        const actualTableauFieldName = columns[colIndex].fieldName;

        // Find filter metadata
        const wf = worksheetFilters.find(f => normalizeName(f.fieldName) === normalizeName(actualFieldName));

        // For range filters
        if (wf && wf.filterType === "range") {
          if (Array.isArray(rawVals) && rawVals.length >= 2) {
            try {
              console.log(`Applying range filter ${actualTableauFieldName}:`, rawVals[0], rawVals[1]);
              await targetWs.applyRangeFilterAsync(actualTableauFieldName, { min: rawVals[0], max: rawVals[1] });
              applied.push(actualTableauFieldName);
            } catch (err) {
              console.error(`Failed to apply range filter ${actualTableauFieldName}:`, err);
              skipped.push(fieldName);
            }
          } else {
            console.warn(`Range filter ${actualTableauFieldName} expected 2 values, got:`, rawVals);
            skipped.push(fieldName);
          }
          continue;
        }

        // For categorical filters - VALIDATE AGAINST DOMAIN
        if (!Array.isArray(rawVals) || rawVals.length === 0) {
          console.warn(`No values for filter ${actualTableauFieldName}, skipping`);
          skipped.push(fieldName);
          continue;
        }

        // Build domain map for validation
        const domainValues = new Map(); // lowercase -> actual value
        for (const row of summaryData.data) {
          const cell = row[colIndex];
          const fv = getCellFormattedValue(cell);
          if (fv !== null && fv !== undefined) {
            const key = String(fv).toLowerCase();
            if (!domainValues.has(key)) {
              domainValues.set(key, fv); // Store the first actual value
            }
          }
        }

        // Validate each AI-provided value
        const validatedValues = [];
        for (const rawVal of rawVals) {
          const lowerRawVal = String(rawVal).toLowerCase();
          if (domainValues.has(lowerRawVal)) {
            validatedValues.push(domainValues.get(lowerRawVal)); // Use the actual domain value
          } else {
            console.warn(`Value '${rawVal}' not found in domain for field '${actualTableauFieldName}'. Available values:`, Array.from(domainValues.values()));
          }
        }

        if (validatedValues.length === 0) {
          console.warn(`No valid values found for filter ${actualTableauFieldName}, skipping`);
          skipped.push(fieldName);
          continue;
        }

        try {
          console.log(`Applying categorical filter ${actualTableauFieldName} with validated values:`, validatedValues);
          await targetWs.applyFilterAsync(actualTableauFieldName, validatedValues, tableau.FilterUpdateType.Replace);
          applied.push(actualTableauFieldName);
        } catch (err) {
          console.error(`Failed to apply filter ${actualTableauFieldName}:`, err);
          skipped.push(fieldName);
        }
      } // end for each filter

      return { applied, skipped };
    }

    // ---------- askAI() - calls backend and then applies filters ----------
    async function askAI() {
      const question = document.getElementById("question").value.trim();
      const output = document.getElementById("output");
      if (!question) { output.innerText = "Please enter a question."; return; }
      output.innerHTML = "<em>Thinking...</em>";

      try {
        const res = await fetch("https://ej-tableau-ai-api-c5gvdag0gdhrbnca.eastus-01.azurewebsites.net/ai_query", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: question })
        });

        if (!res.ok) {
          const text = await res.text().catch(()=>null);
          throw new Error(`API request failed: ${res.status} ${res.statusText} ${text||""}`);
        }

        const data = await res.json();

        output.innerHTML = `
          <b>Summary:</b><br>${data.summary || "(no summary)"}<br><br>
          <b>Top rows (sample):</b><br><pre>${JSON.stringify(data.rows?.slice(0,10) ?? [], null, 2)}</pre><br>
          <b>SQL:</b><br><pre>${data.sql ?? "(none)"}</pre>
        `;

        if (data.filters && Object.keys(data.filters).length > 0) {
          console.log("Filters returned by AI:", data.filters);

          const result = await applyFiltersFromResponse(data.filters, "Report Builder ");
          console.log("applyFiltersFromResponse result:", result);

          output.innerHTML += `<div class="log">Filters applied: ${JSON.stringify(result.applied)}</div>`;
          if (result.skipped && result.skipped.length) {
            output.innerHTML += `<div class="warn">Filters skipped / not matched: ${JSON.stringify(result.skipped)}</div>`;
          }
        } else {
          console.log("No filters returned from AI.");
        }

      } catch (err) {
        console.error("askAI() error:", err);
        output.innerHTML = `<div class="err">Error: ${err.message}</div>`;
      }
    }
  </script>
</head>

<body>
  <h2>AI Data Assistant</h2>
  <p>Ask a question about your data:</p>

  <input id="question" placeholder="e.g., Show me Facebook spend by week" />
  <button id="askButton" onclick="askAI()">Ask</button>

  <div id="output"></div>
</body>
</html>