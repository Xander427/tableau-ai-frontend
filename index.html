<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Data Assistant</title>

  <!-- Local extension API - you already have this file in your site root -->
  <script src="tableau.extensions.1.14.0.min.js"></script>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f5f6fa;
      margin: 0;
      padding: 15px;
    }

    h2 { margin-top: 0; }
    #question {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    #askButton {
      display: block;
      margin-top: 10px;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: #2f7df6;
      color: white;
      font-weight: 500;
      cursor: pointer;
    }
    #askButton:hover { background: #1e5fd1; }

    #output {
      margin-top: 15px;
      padding: 10px;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 50vh;
      overflow: auto;
    }

    .log { color: #333; font-size: 12px; margin-top: 6px; }
    .warn { color: #b36b00; }
    .err { color: #b00020; }
  </style>

  <script>
    // ---------- Initialization ----------
    async function init() {
      try {
        await tableau.extensions.initializeAsync();
        console.log("✅ Tableau Extension initialized. window.tableau:", !!window.tableau);

        const dashboard = tableau.extensions.dashboardContent.dashboard;
        console.log("Dashboard name:", dashboard.name);
        console.log("Worksheets available:", dashboard.worksheets.map(w => w.name));

      } catch (err) {
        console.error("Failed to initialize Tableau Extension:", err);
      }
    }

    document.addEventListener("DOMContentLoaded", init);

    // ---------- Helpers ----------
    // Normalize names (trim) to avoid trailing-space mismatches
    function normalizeName(n) { return (n || "").toString().trim(); }

    // Try to find the right worksheet: prefer exact trimmed match, else fallback to first
    function findWorksheetByName(dashboard, desiredName) {
      if (!dashboard || !dashboard.worksheets || dashboard.worksheets.length === 0) return null;
      const trimmed = normalizeName(desiredName);
      const found = dashboard.worksheets.find(ws => normalizeName(ws.name) === trimmed);
      if (found) return found;
      // fallback: try includes
      const fuzzy = dashboard.worksheets.find(ws => normalizeName(ws.name).includes(trimmed));
      return fuzzy || dashboard.worksheets[0];
    }

    // Extract a usable formatted value from a summary cell
    function getCellFormattedValue(cell) {
      if (!cell) return null;
      return cell.formattedValue ?? cell._formattedValue ?? cell.value ?? cell._value ?? null;
    }

    // ---------- Core: apply filters from AI response ----------
    async function applyFiltersFromResponse(filtersObj, desiredWorksheetName = "Report Builder ") {
      if (!window.tableau) {
        console.warn("Tableau object not detected; skipping filter apply.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      const dashboard = tableau.extensions.dashboardContent.dashboard;
      const targetWs = findWorksheetByName(dashboard, desiredWorksheetName);
      if (!targetWs) {
        console.warn("No worksheet found to apply filters to.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      console.log("Applying filters to worksheet:", targetWs.name);
      const applied = [];
      const skipped = [];

      // Get current filter state
      let worksheetFilters = [];
      try {
        worksheetFilters = await targetWs.getFiltersAsync();
      } catch (e) {
        console.warn("Could not retrieve worksheet filters metadata:", e);
      }

      // Get parameters for the dashboard
      let parameters = [];
      try {
        parameters = await dashboard.getParametersAsync();
        console.log("Available parameters:", parameters.map(p => p.name));
      } catch (e) {
        console.warn("Could not retrieve parameters:", e);
      }

      // Get summary data for validation
      let summaryData = null;
      let columns = null;
      try {
        summaryData = await targetWs.getSummaryDataAsync({ maxRows: 10000 });
        columns = summaryData.columns;
      } catch (e) {
        console.warn("Could not retrieve summary data:", e);
      }

      for (const [fieldRaw, rawVals] of Object.entries(filtersObj || {})) {
        const fieldName = fieldRaw.trim();
        
        // SPECIAL HANDLING FOR DATE GRANULARITY
        let actualFieldName = fieldName;
        if (fieldName.toLowerCase() === "date granularity") {
          actualFieldName = "Date Granularity Selector";
        }

        // CHECK IF IT'S A PARAMETER
        const param = parameters.find(p => normalizeName(p.name) === normalizeName(actualFieldName));
        if (param) {
          if (Array.isArray(rawVals) && rawVals.length > 0) {
            const paramValue = String(rawVals[0]).trim();
            try {
              console.log(`Setting parameter ${actualFieldName} to:`, paramValue);
              await param.changeValueAsync(paramValue);
              applied.push(actualFieldName);
            } catch (err) {
              console.error(`Failed to set parameter ${actualFieldName}:`, err);
              skipped.push(fieldName);
            }
          } else {
            console.warn(`No values for parameter ${actualFieldName}, skipping`);
            skipped.push(fieldName);
          }
          continue;
        }

        // It's a regular filter - proceed with validation
        const colIndex = columns?.findIndex(c => normalizeName(c.fieldName) === normalizeName(actualFieldName));
        if (colIndex === -1) {
          console.warn(`Field '${actualFieldName}' not found in data source`);
          skipped.push(fieldName);
          continue;
        }

        const actualTableauFieldName = columns[colIndex].fieldName;
        const wf = worksheetFilters.find(f => normalizeName(f.fieldName) === normalizeName(actualFieldName));

        // ========== ENHANCED DATE RANGE HANDLING ==========
        if (wf && wf.filterType === "range") {
          if (Array.isArray(rawVals) && rawVals.length >= 1 && rawVals.length <= 2) {
            try {
              let minVal = rawVals[0];
              let maxVal = rawVals.length === 2 ? rawVals[1] : null;
              
              // If only one date provided, auto-detect the missing bound
              if (rawVals.length === 1) {
                console.log(`Single date provided for range filter ${actualTableauFieldName}, auto-detecting range...`);
                
                // Get all date values from data
                const dateValues = summaryData.data
                  .map(row => getCellFormattedValue(row[colIndex]))
                  .filter(v => v !== null && v !== undefined)
                  .sort();
                
                if (dateValues.length > 0) {
                  // Assume single date is start date, use data max as end date
                  // For "2025", this means 2025-01-01 to max(date)
                  minVal = rawVals[0];
                  maxVal = dateValues[dateValues.length - 1];
                  console.log(`Auto-detected date range: ${minVal} to ${maxVal}`);
                } else {
                  console.warn("No date values found in data, skipping");
                  skipped.push(fieldName);
                  continue;
                }
              }
              
              // Convert to Date objects (Tableau expects Date objects or ISO strings)
              const minDate = new Date(minVal);
              const maxDate = new Date(maxVal);
              
              console.log(`Applying range filter ${actualTableauFieldName}:`, minDate, "to", maxDate);
              
              await targetWs.applyRangeFilterAsync(actualTableauFieldName, { 
                min: minDate, 
                max: maxDate 
              });
              applied.push(actualTableauFieldName);
              
            } catch (err) {
              console.error(`Failed to apply range filter ${actualTableauFieldName}:`, err);
              skipped.push(fieldName);
            }
          } else {
            console.warn(`Range filter ${actualTableauFieldName} expected 1-2 values, got:`, rawVals);
            skipped.push(fieldName);
          }
          continue;
        }

        // For categorical filters - VALIDATE AGAINST DOMAIN
        // ========== FIXED: CATEGORICAL FILTER WITH FULL DOMAIN ==========
        if (!Array.isArray(rawVals) || rawVals.length === 0) {
          console.warn(`❌ No values for filter ${actualTableauFieldName}`);
          skipped.push(fieldName);
          continue;
        }

        // Get domain from filter metadata (full domain, not filtered)
        let domainValues = new Map();
        let domainDisplay = [];

        if (wf && wf.getDomainAsync) {
          try {
            const domain = await wf.getDomainAsync();
            console.log(`Getting full domain for ${actualTableauFieldName}...`);
            
            for (const domainVal of domain.values) {
              const fv = getCellFormattedValue(domainVal);
              if (fv !== null && fv !== undefined) {
                const key = String(fv).toLowerCase();
                if (!domainValues.has(key)) {
                  domainValues.set(key, fv);
                  domainDisplay.push(fv);
                }
              }
            }
            console.log(`Full domain values:`, domainDisplay);
          } catch (e) {
            console.warn(`Could not get domain for ${actualTableauFieldName}, falling back to summary data:`, e);
            
            // Fallback to summary data if getDomainAsync fails
            for (const row of summaryData.data) {
              const cell = row[colIndex];
              const fv = getCellFormattedValue(cell);
              if (fv !== null && fv !== undefined) {
                const key = String(fv).toLowerCase();
                if (!domainValues.has(key)) {
                  domainValues.set(key, fv);
                  domainDisplay.push(fv);
                }
              }
            }
          }
        } else {
          // Fallback to summary data if no getDomainAsync
          console.warn(`No getDomainAsync available for ${actualTableauFieldName}, using summary data`);
          for (const row of summaryData.data) {
            const cell = row[colIndex];
            const fv = getCellFormattedValue(cell);
            if (fv !== null && fv !== undefined) {
              const key = String(fv).toLowerCase();
              if (!domainValues.has(key)) {
                domainValues.set(key, fv);
                domainDisplay.push(fv);
              }
            }
          }
        }

        console.log(`Domain values for ${actualTableauFieldName}:`, domainDisplay);

        // Validate each AI-provided value
        const validatedValues = [];
        for (const rawVal of rawVals) {
          const lowerRawVal = String(rawVal).toLowerCase();
          if (domainValues.has(lowerRawVal)) {
            validatedValues.push(domainValues.get(lowerRawVal));
          } else {
            console.error(`❌ Value '${rawVal}' not found in domain. Available:`, domainDisplay);
          }
        }

        if (validatedValues.length === 0) {
          console.error(`❌ No valid values found for filter ${actualTableauFieldName}`);
          skipped.push(fieldName);
          continue;
        }

        try {
          console.log(`Applying categorical filter ${actualTableauFieldName} with:`, validatedValues);
          await targetWs.applyFilterAsync(actualTableauFieldName, validatedValues, tableau.FilterUpdateType.Replace);
          applied.push(actualTableauFieldName);
          console.log(`✅ Categorical filter applied successfully`);
        } catch (err) {
          console.error(`❌ Failed to apply filter:`, err);
          skipped.push(fieldName);
        }
      } // end for each filter

      return { applied, skipped };
    }

    // ---------- askAI() - calls backend and then applies filters ----------
    async function askAI() {
      const question = document.getElementById("question").value.trim();
      const output = document.getElementById("output");
      if (!question) { output.innerText = "Please enter a question."; return; }
      output.innerHTML = "<em>Thinking...</em>";

      try {
        const res = await fetch("https://ej-tableau-ai-api-c5gvdag0gdhrbnca.eastus-01.azurewebsites.net/ai_query", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: question })
        });

        if (!res.ok) {
          const text = await res.text().catch(()=>null);
          throw new Error(`API request failed: ${res.status} ${res.statusText} ${text||""}`);
        }

        const data = await res.json();

        output.innerHTML = `
          <b>Summary:</b><br>${data.summary || "(no summary)"}<br><br>
          <b>Top rows (sample):</b><br><pre>${JSON.stringify(data.rows?.slice(0,10) ?? [], null, 2)}</pre><br>
          <b>SQL:</b><br><pre>${data.sql ?? "(none)"}</pre>
        `;

        if (data.filters && Object.keys(data.filters).length > 0) {
          console.log("Filters returned by AI:", data.filters);

          const result = await applyFiltersFromResponse(data.filters, "Report Builder ");
          console.log("applyFiltersFromResponse result:", result);

          output.innerHTML += `<div class="log">Filters applied: ${JSON.stringify(result.applied)}</div>`;
          if (result.skipped && result.skipped.length) {
            output.innerHTML += `<div class="warn">Filters skipped / not matched: ${JSON.stringify(result.skipped)}</div>`;
          }
        } else {
          console.log("No filters returned from AI.");
        }

      } catch (err) {
        console.error("askAI() error:", err);
        output.innerHTML = `<div class="err">Error: ${err.message}</div>`;
      }
    }
  </script>
</head>

<body>
  <h2>AI Data Assistant</h2>
  <p>Ask a question about your data:</p>

  <input id="question" placeholder="e.g., Show me Facebook spend by week" />
  <button id="askButton" onclick="askAI()">Ask</button>

  <div id="output"></div>
</body>
</html>