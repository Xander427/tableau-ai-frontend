<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Data Assistant</title>

  <!-- Local extension API - you already have this file in your site root -->
  <script src="tableau.extensions.1.14.0.min.js"></script>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f5f6fa;
      margin: 0;
      padding: 15px;
    }

    h2 { margin-top: 0; }
    #question {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    #askButton {
      display: block;
      margin-top: 10px;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: #2f7df6;
      color: white;
      font-weight: 500;
      cursor: pointer;
    }
    #askButton:hover { background: #1e5fd1; }

    #output {
      margin-top: 15px;
      padding: 10px;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 50vh;
      overflow: auto;
    }

    .log { color: #333; font-size: 12px; margin-top: 6px; }
    .warn { color: #b36b00; }
    .err { color: #b00020; }
  </style>

  <script>
    // ---------- Initialization ----------
    async function init() {
      try {
        await tableau.extensions.initializeAsync();
        console.log("âœ… Tableau Extension initialized. window.tableau:", !!window.tableau);

        const dashboard = tableau.extensions.dashboardContent.dashboard;
        console.log("Dashboard name:", dashboard.name);
        console.log("Worksheets available:", dashboard.worksheets.map(w => w.name));

      } catch (err) {
        console.error("Failed to initialize Tableau Extension:", err);
      }
    }

    document.addEventListener("DOMContentLoaded", init);

    // ---------- Helpers ----------
    // Normalize names (trim) to avoid trailing-space mismatches
    function normalizeName(n) { return (n || "").toString().trim(); }

    // Try to find the right worksheet: prefer exact trimmed match, else fallback to first
    function findWorksheetByName(dashboard, desiredName) {
      if (!dashboard || !dashboard.worksheets || dashboard.worksheets.length === 0) return null;
      const trimmed = normalizeName(desiredName);
      const found = dashboard.worksheets.find(ws => normalizeName(ws.name) === trimmed);
      if (found) return found;
      // fallback: try includes
      const fuzzy = dashboard.worksheets.find(ws => normalizeName(ws.name).includes(trimmed));
      return fuzzy || dashboard.worksheets[0];
    }

    // Extract a usable formatted value from a summary cell
    function getCellFormattedValue(cell) {
      if (!cell) return null;
      // historical API uses properties like formattedValue, _formattedValue, formatted
      return cell.formattedValue ?? cell._formattedValue ?? cell.value ?? cell._value ?? null;
    }

    // Get a Tableau "value object" for a given field/value by scanning summary rows
    // Returns the whole cell object (which Tableau accepts when applying categorical filters)
    async function getFilterValueObj(worksheet, fieldName, rawValue) {
      if (!worksheet) return null;
      try {
        // Ask for a larger sample in case the matching value isn't in the first few rows
        const summary = await worksheet.getSummaryDataAsync({ maxRows: 10000 });
        const colIndex = summary.columns.findIndex(c => normalizeName(c.fieldName) === normalizeName(fieldName));
        if (colIndex === -1) {
          // try case-insensitive or trimmed match
          const altIndex = summary.columns.findIndex(c => normalizeName(c.fieldName).toLowerCase() === normalizeName(fieldName).toLowerCase());
          if (altIndex === -1) return null;
          else colIndex = altIndex;
        }

        for (const row of summary.data) {
          const cell = row[colIndex];
          const fv = getCellFormattedValue(cell);
          if (fv === null || fv === undefined) continue;
          // exact match first
          if (String(fv) === String(rawValue)) return cell;
          // case-insensitive match
          if (String(fv).toLowerCase() === String(rawValue).toLowerCase()) return cell;
        }

        // not found
        return null;
      } catch (e) {
        console.warn("getFilterValueObj error:", e);
        return null;
      }
    }

    // ---------- Core: apply filters from AI response ----------
    // filtersObj: { FieldName: [value1, value2], ... }
    async function applyFiltersFromResponse(filtersObj, desiredWorksheetName = "Report Builder ") {
      if (!window.tableau) {
        console.warn("Tableau object not detected; skipping filter apply.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      const dashboard = tableau.extensions.dashboardContent.dashboard;
      const targetWs = findWorksheetByName(dashboard, desiredWorksheetName);
      if (!targetWs) {
        console.warn("No worksheet found to apply filters to.");
        return { applied: [], skipped: Object.keys(filtersObj || {}) };
      }

      console.log("Applying filters to worksheet:", targetWs.name);
      const applied = [];
      const skipped = [];

      // Get worksheet filter metadata so we know filter types
      let worksheetFilters = [];
      try {
        worksheetFilters = await targetWs.getFiltersAsync();
      } catch (e) {
        console.warn("Could not retrieve worksheet filters metadata:", e);
      }

      for (const [fieldRaw, rawVals] of Object.entries(filtersObj || {})) {
        const fieldName = fieldRaw; // keep original; matching is flexible
        const wf = worksheetFilters.find(f => normalizeName(f.fieldName) === normalizeName(fieldName));

        // If the worksheet has a range filter for this field, and the AI provided two values, apply range
        if (wf && wf.filterType === "range") {
          // Expect rawVals like ["2025-01-01","2025-01-31"] or [min, max]
          if (Array.isArray(rawVals) && rawVals.length >= 2) {
            const min = rawVals[0];
            const max = rawVals[1];
            try {
              console.log(`Applying range filter ${fieldName}:`, min, max);
              await targetWs.applyRangeFilterAsync(fieldName, min, max);
              applied.push(fieldName);
            } catch (err) {
              console.error(`Failed to apply range filter ${fieldName}:`, err);
              skipped.push(fieldName);
            }
            continue;
          } else {
            console.warn(`Range filter ${fieldName} expected 2 values, got:`, rawVals);
            skipped.push(fieldName);
            continue;
          }
        }

        // Otherwise treat as categorical
        if (!Array.isArray(rawVals) || rawVals.length === 0) {
          console.warn(`No values for filter ${fieldName}, skipping`);
          skipped.push(fieldName);
          continue;
        }

        // For categorical filters, just pass the string values directly
        // Tableau will match them against its domain
        const stringValues = rawVals.map(v => String(v).trim());

        try {
          console.log(`Applying categorical filter ${fieldName} =>`, stringValues);
          await targetWs.applyFilterAsync(fieldName, stringValues, tableau.FilterUpdateType.Replace);
          applied.push(fieldName);
        } catch (err) {
          console.error(`Failed to apply filter ${fieldName}:`, err);
          skipped.push(fieldName);
        }
      } // end for each filter

      return { applied, skipped };
    }

    // ---------- askAI() - calls backend and then applies filters ----------
    async function askAI() {
      const question = document.getElementById("question").value.trim();
      const output = document.getElementById("output");
      if (!question) { output.innerText = "Please enter a question."; return; }
      output.innerHTML = "<em>Thinking...</em>";

      try {
        const res = await fetch("https://ej-tableau-ai-api-c5gvdag0gdhrbnca.eastus-01.azurewebsites.net/ai_query", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: question })
        });

        if (!res.ok) {
          const text = await res.text().catch(()=>null);
          throw new Error(`API request failed: ${res.status} ${res.statusText} ${text||""}`);
        }

        const data = await res.json();

        output.innerHTML = `
          <b>Summary:</b><br>${data.summary || "(no summary)"}<br><br>
          <b>Top rows (sample):</b><br><pre>${JSON.stringify(data.rows?.slice(0,10) ?? [], null, 2)}</pre><br>
          <b>SQL:</b><br><pre>${data.sql ?? "(none)"}</pre>
        `;

        if (data.filters && Object.keys(data.filters).length > 0) {
          console.log("Filters returned by AI:", data.filters);

          const result = await applyFiltersFromResponse(data.filters, "Report Builder ");
          console.log("applyFiltersFromResponse result:", result);

          output.innerHTML += `<div class="log">Filters applied: ${JSON.stringify(result.applied)}</div>`;
          if (result.skipped && result.skipped.length) {
            output.innerHTML += `<div class="warn">Filters skipped / not matched: ${JSON.stringify(result.skipped)}</div>`;
          }
        } else {
          console.log("No filters returned from AI.");
        }

      } catch (err) {
        console.error("askAI() error:", err);
        output.innerHTML = `<div class="err">Error: ${err.message}</div>`;
      }
    }
  </script>
</head>

<body>
  <h2>AI Data Assistant</h2>
  <p>Ask a question about your data:</p>

  <input id="question" placeholder="e.g., Show me Facebook spend by week" />
  <button id="askButton" onclick="askAI()">Ask</button>

  <div id="output"></div>
</body>
</html>
